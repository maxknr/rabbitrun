<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Rabbit Runner</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            width: 100%;
            height: 100vh;
            touch-action: manipulation; /* Prevent double-tap zoom on mobile */
        }
        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Set canvas to full screen with device pixel ratio for mobile
        function resizeCanvas() {
            const dpr = window.devicePixelRatio || 1;
            canvas.width = window.innerWidth * dpr;
            canvas.height = window.innerHeight * dpr;
            canvas.style.width = window.innerWidth + 'px';
            canvas.style.height = window.innerHeight + 'px';
            ctx.scale(dpr, dpr);
            console.log('Canvas resized: DPR=', dpr, 'Width=', canvas.width, 'Height=', canvas.height);
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // Audio setup
        let backgroundMusicLevel1, backgroundMusicLevel2, currentBackgroundMusic;
        let jumpSound, crashSound, coinSound, levelUpSound;
        let isAudioInitialized = false;
        let isBackgroundMusicPlaying = false;

        function initializeAudio() {
            if (!isAudioInitialized) {
                try {
                    backgroundMusicLevel1 = new Audio('sound/bglevel1.mp3');
                    backgroundMusicLevel2 = new Audio('sound/bglevel2.mp3');
                    jumpSound = new Audio('sound/jump.mp3');
                    crashSound = new Audio('sound/crash.mp3');
                    coinSound = new Audio('sound/coin.mp3');
                    levelUpSound = new Audio('sound/levelup.mp3');

                    // Add error event listeners for debugging
                    const audioFiles = {
                        bglevel1: backgroundMusicLevel1,
                        bglevel2: backgroundMusicLevel2,
                        jump: jumpSound,
                        crash: crashSound,
                        coin: coinSound,
                        levelup: levelUpSound
                    };
                    for (const [name, audio] of Object.entries(audioFiles)) {
                        audio.onerror = () => console.error(`Failed to load audio: ${name} (${audio.src}). Check if file exists at https://maxknr.github.io/rabbitrun/sound/${name}.mp3`);
                        audio.oncanplay = () => console.log(`Audio loaded successfully: ${name} (${audio.src})`);
                    }

                    console.log('Audio initialized:', {
                        bglevel1: backgroundMusicLevel1.src,
                        bglevel2: backgroundMusicLevel2.src,
                        jump: jumpSound.src,
                        crash: crashSound.src,
                        coin: coinSound.src,
                        levelup: levelUpSound.src
                    });

                    backgroundMusicLevel1.loop = true;
                    backgroundMusicLevel2.loop = true;
                    backgroundMusicLevel1.volume = 0.2;
                    backgroundMusicLevel2.volume = 0.2;
                    jumpSound.volume = 0.5;
                    crashSound.volume = 0.5;
                    coinSound.volume = 0.5;
                    levelUpSound.volume = 0.5;
                    currentBackgroundMusic = backgroundMusicLevel1;
                    isAudioInitialized = true;
                } catch (e) {
                    console.error('Audio initialization failed:', e);
                    backgroundMusicLevel1 = { play: () => {}, pause: () => {} };
                    backgroundMusicLevel2 = { play: () => {}, pause: () => {} };
                    currentBackgroundMusic = backgroundMusicLevel1;
                    jumpSound = { play: () => {} };
                    crashSound = { play: () => {} };
                    coinSound = { play: () => {} };
                    levelUpSound = { play: () => {} };
                }
            }
        }

        // Function to switch and play background music
        function playBackgroundMusic(level) {
            try {
                if (!isBackgroundMusicPlaying || currentBackgroundMusic !== (level === 1 ? backgroundMusicLevel1 : backgroundMusicLevel2)) {
                    currentBackgroundMusic.pause();
                    currentBackgroundMusic.currentTime = 0; // Reset only when switching tracks
                    currentBackgroundMusic = (level === 1) ? backgroundMusicLevel1 : backgroundMusicLevel2;
                    console.log('Playing background music for level', level, ':', currentBackgroundMusic.src);
                    currentBackgroundMusic.play().catch(e => console.error('Background music failed to play:', e));
                    isBackgroundMusicPlaying = true;
                }
            } catch (e) {
                console.error('Background music failed to play:', e);
            }
        }

        // Game variables
        let rabbit = {
            x: 50,
            y: 0,
            width: 50,
            height: 50,
            jumpForce: 15,
            velocityY: 0,
            isJumping: false
        };
        let gravity = 0.6;
        let obstacles = [];
        let clouds = [];
        let coinClouds = [];
        let score = 0;
        let gameSpeed = 5;
        let gameOver = false;
        let groundY = 0;
        let scoreFlash = 0;
        let level = 1;
        let showSplashScreen = false;
        let splashScreenTimer = 0;
        let obstacleSpawnInterval = 1500;

        // Cloud generation (regular clouds)
        function spawnCloud() {
            let cloud = {
                x: canvas.width / (window.devicePixelRatio || 1),
                y: Math.random() * (canvas.height / (window.devicePixelRatio || 1) / 2 - 50) + 50,
                width: Math.random() * 50 + 50,
                height: Math.random() * 20 + 20,
                speed: Math.random() * 2 + 1
            };
            clouds.push(cloud);
        }

        // Coin cloud generation
        function spawnCoinCloud() {
            let maxJumpHeight = groundY - (rabbit.jumpForce * rabbit.jumpForce) / (2 * gravity);
            let coinCloud = {
                x: canvas.width / (window.devicePixelRatio || 1),
                y: maxJumpHeight + Math.random() * 50 + 50,
                width: 60,
                height: 30,
                speed: Math.random() * 1 + 1,
                hasCoin: true
            };
            coinClouds.push(coinCloud);
        }

        // Draw sky background with gradient based on level
        function drawSky() {
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height / (window.devicePixelRatio || 1));
            if (level === 1) {
                gradient.addColorStop(0, '#87CEEB');
                gradient.addColorStop(1, '#1E90FF');
            } else {
                gradient.addColorStop(0, '#FF4500');
                gradient.addColorStop(1, '#800080');
            }
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width / (window.devicePixelRatio || 1), canvas.height / (window.devicePixelRatio || 1));
        }

        // Draw regular clouds
        function drawClouds() {
            clouds.forEach((cloud, index) => {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.beginPath();
                ctx.ellipse(cloud.x, cloud.y, cloud.width / 2, cloud.height / 2, 0, 0, Math.PI * 2);
                ctx.fill();
                cloud.x -= cloud.speed;
                if (cloud.x < -cloud.width) {
                    clouds.splice(index, 1);
                }
            });
        }

        // Draw coin clouds
        function drawCoinClouds() {
            coinClouds.forEach((coinCloud, index) => {
                if (coinCloud.hasCoin) {
                    ctx.fillStyle = 'rgba(255, 215, 0, 0.7)';
                    ctx.beginPath();
                    ctx.ellipse(coinCloud.x, coinCloud.y, coinCloud.width / 2, coinCloud.height / 2, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#FFD700';
                    ctx.beginPath();
                    ctx.arc(coinCloud.x, coinCloud.y, 10, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#000000';
                    ctx.font = `12px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('C', coinCloud.x, coinCloud.y);
                }
                coinCloud.x -= coinCloud.speed;
                if (coinCloud.x < -coinCloud.width) {
                    coinClouds.splice(index, 1);
                }
            });
        }

        // Rabbit drawing
        function drawRabbit() {
            ctx.fillStyle = '#8B4513';
            ctx.beginPath();
            ctx.ellipse(rabbit.x, rabbit.y, rabbit.width / 2, rabbit.height / 1.5, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#8B4513';
            ctx.beginPath();
            ctx.arc(rabbit.x, rabbit.y - rabbit.height / 2, rabbit.width / 3, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#8B4513';
            ctx.beginPath();
            ctx.moveTo(rabbit.x - 10, rabbit.y - rabbit.height / 1.5);
            ctx.quadraticCurveTo(rabbit.x - 15, rabbit.y - rabbit.height - 10, rabbit.x - 10, rabbit.y - rabbit.height - 20);
            ctx.quadraticCurveTo(rabbit.x - 5, rabbit.y - rabbit.height - 10, rabbit.x - 5, rabbit.y - rabbit.height / 1.5);
            ctx.fill();
            ctx.beginPath();
            ctx.moveTo(rabbit.x + 10, rabbit.y - rabbit.height / 1.5);
            ctx.quadraticCurveTo(rabbit.x + 15, rabbit.y - rabbit.height - 10, rabbit.x + 10, rabbit.y - rabbit.height - 20);
            ctx.quadraticCurveTo(rabbit.x + 5, rabbit.y - rabbit.height - 10, rabbit.x + 5, rabbit.y - rabbit.height / 1.5);
            ctx.fill();
            ctx.fillStyle = '#FFB6C1';
            ctx.beginPath();
            ctx.moveTo(rabbit.x - 8, rabbit.y - rabbit.height / 1.5);
            ctx.quadraticCurveTo(rabbit.x - 13, rabbit.y - rabbit.height - 8, rabbit.x - 8, rabbit.y - rabbit.height - 15);
            ctx.quadraticCurveTo(rabbit.x - 3, rabbit.y - rabbit.height - 8, rabbit.x - 3, rabbit.y - rabbit.height / 1.5);
            ctx.fill();
            ctx.beginPath();
            ctx.moveTo(rabbit.x + 8, rabbit.y - rabbit.height / 1.5);
            ctx.quadraticCurveTo(rabbit.x + 13, rabbit.y - rabbit.height - 8, rabbit.x + 8, rabbit.y - rabbit.height - 15);
            ctx.quadraticCurveTo(rabbit.x + 3, rabbit.y - rabbit.height - 8, rabbit.x + 3, rabbit.y - rabbit.height / 1.5);
            ctx.fill();
            ctx.fillStyle = '#FFFFFF';
            ctx.beginPath();
            ctx.arc(rabbit.x - 8, rabbit.y - rabbit.height / 1.8, 5, 0, Math.PI * 2);
            ctx.arc(rabbit.x + 8, rabbit.y - rabbit.height / 1.8, 5, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#000000';
            ctx.beginPath();
            ctx.arc(rabbit.x - 8, rabbit.y - rabbit.height / 1.8, 2, 0, Math.PI * 2);
            ctx.arc(rabbit.x + 8, rabbit.y - rabbit.height / 1.8, 2, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#FFB6C1';
            ctx.beginPath();
            ctx.moveTo(rabbit.x, rabbit.y - rabbit.height / 2);
            ctx.lineTo(rabbit.x - 3, rabbit.y - rabbit.height / 2 + 5);
            ctx.lineTo(rabbit.x + 3, rabbit.y - rabbit.height / 2 + 5);
            ctx.closePath();
            ctx.fill();
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(rabbit.x - 5, rabbit.y - rabbit.height / 2 + 5);
            ctx.lineTo(rabbit.x - 15, rabbit.y - rabbit.height / 2 + 7);
            ctx.moveTo(rabbit.x - 5, rabbit.y - rabbit.height / 2 + 3);
            ctx.lineTo(rabbit.x - 13, rabbit.y - rabbit.height / 2 + 3);
            ctx.moveTo(rabbit.x + 5, rabbit.y - rabbit.height / 2 + 5);
            ctx.lineTo(rabbit.x + 15, rabbit.y - rabbit.height / 2 + 7);
            ctx.moveTo(rabbit.x + 5, rabbit.y - rabbit.height / 2 + 3);
            ctx.lineTo(rabbit.x + 13, rabbit.y - rabbit.height / 2 + 3);
            ctx.stroke();
            ctx.fillStyle = '#FFFFFF';
            ctx.beginPath();
            ctx.arc(rabbit.x + rabbit.width / 2 - 5, rabbit.y + rabbit.height / 4, 8, 0, Math.PI * 2);
            ctx.fill();
        }

        // Obstacle drawing (carrots for level 1, rocks for level 2)
        function drawObstacle(x, y, width, height) {
            if (level === 1) {
                ctx.fillStyle = '#FFA500';
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(x + width / 2, y - height);
                ctx.lineTo(x + width, y);
                ctx.closePath();
                ctx.fill();
                ctx.fillStyle = '#008000';
                ctx.fillRect(x + width / 4, y - height - 10, width / 2, 10);
            } else {
                ctx.fillStyle = '#808080';
                ctx.beginPath();
                ctx.roundRect(x, y - height, width, height, 5);
                ctx.fill();
            }
        }

        // Obstacle generation
        function spawnObstacle() {
            let obstacle = {
                x: canvas.width / (window.devicePixelRatio || 1),
                y: groundY,
                width: level === 1 ? 20 : 30,
                height: level === 1 ? 40 : 30
            };
            obstacles.push(obstacle);
        }

        // Draw splash screen
        function drawSplashScreen() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(0, 0, canvas.width / (window.devicePixelRatio || 1), canvas.height / (window.devicePixelRatio || 1));
            ctx.fillStyle = '#FFFFFF';
            ctx.font = `40px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('Level 2 Unlocked! Bonus: 1000 Points', (canvas.width / (window.devicePixelRatio || 1)) / 2, (canvas.height / (window.devicePixelRatio || 1)) / 2);
            if (isAudioInitialized && splashScreenTimer >= 2900) {
                try {
                    console.log('Attempting to play level up sound:', levelUpSound.src);
                    levelUpSound.play().catch(e => console.error('Level up sound failed to play:', e));
                } catch (e) {
                    console.error('Level up sound failed to play:', e);
                }
            }
        }

        // Game loop
        let lastTime = 0;
        let obstacleTimer = 0;
        let cloudTimer = 0;
        let coinCloudTimer = 0;
        function gameLoop(timestamp) {
            if (gameOver) {
                ctx.fillStyle = 'black';
                ctx.font = `30px Arial`;
                ctx.textAlign = 'center';
                ctx.fillText('Game Over! Score: ' + Math.floor(score), (canvas.width / (window.devicePixelRatio || 1)) / 2, (canvas.height / (window.devicePixelRatio || 1)) / 2);
                ctx.fillText('Tap or press SPACE to restart', (canvas.width / (window.devicePixelRatio || 1)) / 2, (canvas.height / (window.devicePixelRatio || 1)) / 2 + 40);
                try {
                    currentBackgroundMusic.pause();
                    isBackgroundMusicPlaying = false;
                } catch (e) {
                    console.error('Failed to pause music:', e);
                }
                return;
            }

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            drawSky();
            if (!showSplashScreen) {
                cloudTimer += timestamp - lastTime;
                if (cloudTimer > 2000) {
                    spawnCloud();
                    cloudTimer = 0;
                }
                drawClouds();

                coinCloudTimer += timestamp - lastTime;
                if (coinCloudTimer > 5000) {
                    spawnCoinCloud();
                    coinCloudTimer = 0;
                }
                drawCoinClouds();
                coinClouds.forEach((coinCloud, index) => {
                    if (coinCloud.hasCoin && 
                        rabbit.x + rabbit.width / 2 > coinCloud.x - coinCloud.width / 2 &&
                        rabbit.x - rabbit.width / 2 < coinCloud.x + coinCloud.width / 2 &&
                        rabbit.y + rabbit.height / 2 > coinCloud.y - coinCloud.height / 2 &&
                        rabbit.y - rabbit.height / 2 < coinCloud.y + coinCloud.height / 2
                    ) {
                        coinCloud.hasCoin = false;
                        score += 50;
                        scoreFlash = 30;
                        if (isAudioInitialized) {
                            try {
                                console.log('Attempting to play coin sound:', coinSound.src);
                                coinSound.play().catch(e => console.error('Coin sound failed to play:', e));
                            } catch (e) {
                                console.error('Coin sound failed to play:', e);
                            }
                        }
                    }
                });

                groundY = (canvas.height / (window.devicePixelRatio || 1)) - 50;
                ctx.fillStyle = '#654321';
                ctx.fillRect(0, groundY, canvas.width / (window.devicePixelRatio || 1), 50);

                rabbit.y = Math.min(rabbit.y + rabbit.velocityY, groundY - rabbit.height / 2);
                rabbit.velocityY += gravity;
                if (rabbit.y >= groundY - rabbit.height / 2) {
                    rabbit.velocityY = 0;
                    rabbit.isJumping = false;
                }
                drawRabbit();

                obstacleTimer += timestamp - lastTime;
                if (obstacleTimer > obstacleSpawnInterval) {
                    spawnObstacle();
                    obstacleTimer = 0;
                }
                obstacles.forEach((obstacle, index) => {
                    obstacle.x -= gameSpeed;
                    drawObstacle(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
                    if (
                        rabbit.x + rabbit.width / 2 > obstacle.x &&
                        rabbit.x - rabbit.width / 2 < obstacle.x + obstacle.width &&
                        rabbit.y + rabbit.height / 2 > obstacle.y - obstacle.height
                    ) {
                        gameOver = true;
                        if (isAudioInitialized) {
                            try {
                                console.log('Attempting to play crash sound:', crashSound.src);
                                crashSound.play().catch(e => console.error('Crash sound failed to play:', e));
                            } catch (e) {
                                console.error('Crash sound failed to play:', e);
                            }
                        }
                    }
                    if (obstacle.x < -obstacle.width) {
                        obstacles.splice(index, 1);
                        score += 10;
                        scoreFlash = 30;
                    }
                });
            }

            if (score >= 500 && level === 1 && !showSplashScreen) {
                showSplashScreen = true;
                splashScreenTimer = 3000;
                score += 1000;
                level = 2;
                gameSpeed = 7;
                obstacleSpawnInterval = 1200;
                obstacles = [];
                coinClouds = [];
                rabbit.y = groundY - rabbit.height / 2;
                rabbit.velocityY = 0;
                rabbit.isJumping = false;
                if (isAudioInitialized) {
                    playBackgroundMusic(2);
                }
            }

            if (showSplashScreen) {
                drawSplashScreen();
                splashScreenTimer -= timestamp - lastTime;
                if (splashScreenTimer <= 0) {
                    showSplashScreen = false;
                }
            }

            ctx.font = `30px Arial`;
            ctx.textAlign = 'left';
            ctx.textBaseline = 'top';
            if (scoreFlash > 0) {
                ctx.fillStyle = scoreFlash % 10 < 5 ? '#FF0000' : '#000000';
                scoreFlash--;
            } else {
                ctx.fillStyle = '#000000';
            }
            ctx.fillText('Score: ' + Math.floor(score) + ' | Level: ' + level, 10, 30);

            lastTime = timestamp;
            requestAnimationFrame(gameLoop);
        }

        // Input handling (keyboard and touch)
        function handleInput() {
            if (gameOver) {
                obstacles = [];
                clouds = [];
                coinClouds = [];
                score = 0;
                gameSpeed = 5;
                obstacleSpawnInterval = 1500;
                level = 1;
                gameOver = false;
                showSplashScreen = false;
                rabbit.y = groundY - rabbit.height / 2;
                rabbit.velocityY = 0;
                scoreFlash = 0;
                if (isAudioInitialized) {
                    playBackgroundMusic(1);
                }
                requestAnimationFrame(gameLoop);
            } else if (!rabbit.isJumping && !showSplashScreen) {
                rabbit.velocityY = -rabbit.jumpForce;
                rabbit.isJumping = true;
                initializeAudio();
                if (!isBackgroundMusicPlaying) {
                    playBackgroundMusic(level);
                }
                if (isAudioInitialized) {
                    try {
                        console.log('Attempting to play jump sound:', jumpSound.src);
                        jumpSound.play().catch(e => console.error('Jump sound failed to play:', e));
                    } catch (e) {
                        console.error('Jump sound failed to play:', e);
                    }
                }
            }
        }

        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space') {
                e.preventDefault(); // Prevent scrolling on space
                handleInput();
            }
        });

        document.addEventListener('touchstart', (e) => {
            e.preventDefault(); // Prevent default touch behavior
            console.log('Touchstart triggered');
            handleInput();
        });

        // Start game
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>
